/*
 * Copyright (c) 2005. All rights reserved.
 */

/*
 * Created on 25 oct. 2004
 */
package org.highway.service.ejb;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;

import org.highway.exception.TechnicalException;
import org.highway.helper.MethodHelper;
import org.highway.io.Deserializer;
import org.highway.io.Serializer;
import org.highway.io.StandardZipDeserializer;
import org.highway.io.StandardZipSerializer;

/**
 * Used by ZipEjbProxy to serialize and zip the parameters and to call the
 * service zip modified internal method. Developers should not use this class.
 * 
 * 
 * 
 */
public class ZipEjbProxyRequest extends EjbRequest
{
	/**
	 * 
	 */
	private String zipMethodName;

	/**
	 * 
	 */
	private static final Class[] methodInternalTypes = new Class[] {byte[].class};


	/**
	 * Constructs an EjbZipRequest.
	 * 
	 * @param serviceClass the service component interface
	 * @param proxy the service component proxy
	 * @param implementation the service component implementation
	 * @param methodName the service method name
	 * @param interceptors the list of interceptors to use in this request
	 * @param zipMethodName the internal method name generated by ejbgen for zip
	 * ejbeans
	 */
	ZipEjbProxyRequest(Class serviceClass, Object proxy, Object implementation,
			String methodName, List interceptors, String zipMethodName)
	{
		super(serviceClass, proxy, implementation, methodName, interceptors);
		this.zipMethodName = zipMethodName;
	}

	protected Object invokeImplementation() throws Throwable
	{
		Object returnValue = null;
		byte[] parameter = zipParameters();
		boolean noParameter = parameter==null;
		
		Method implMethod = getImplementationMethod(noParameter);

		try
		{
			if (noParameter) {
				returnValue = implMethod.invoke(getImplementation(),
						new Object[0]);
				
			}else{ 
				returnValue = implMethod.invoke(getImplementation(),
					new Object[] {parameter});
			}

		}
		catch (IllegalArgumentException exc)
		{
			throw new TechnicalException("failed to invoke "
					+ MethodHelper.getClassAndMethodName(implMethod, true), exc);
		}
		catch (IllegalAccessException exc)
		{
			throw new TechnicalException("failed to invoke "
					+ MethodHelper.getClassAndMethodName(implMethod, true), exc);
		}
		catch (InvocationTargetException exc)
		{
			throw exc.getTargetException();
		}

		return unzipReturnValue((byte[]) returnValue);
	}

	private Object unzipReturnValue(byte[] bytes)
	{
		if (bytes == null) return null;
		Deserializer deserializer = new StandardZipDeserializer(bytes);
		return deserializer.readObject();
	}

	private byte[] zipParameters()
	{
		int length = getParameterNumber();
		if (length == 0) return null;
		
		Serializer serializer = new StandardZipSerializer();

		for (int i = 0; i < length; i++)
		{
			// if the paremeter class is a primitive
			// the value is unwrapped before to be serialized and zipped
			// by this method
			serializer.write(getParameterValue(3*i), getParameterClass(3*i));
		}

		return serializer.toByteArray();
	}

	private Method getImplementationMethod(boolean nullable)
	{
		// TODO see how we could use the MethodHelper class to share
		// this kind of technical logic

		Class implClass = getImplementation().getClass();

		try
		{

			if (nullable)
				return implClass.getDeclaredMethod(zipMethodName,
						new Class[0]);

				// TODO why do we only get the declared method?
			// Should we care if the method is directly declared in the
			// implementation class and not in super classes?
			return implClass.getDeclaredMethod(zipMethodName,
					methodInternalTypes);
		}
		catch (SecurityException exc)
		{
			throw new TechnicalException("failed to get method = "
					+ zipMethodName + " on implementation class = "
					+ implClass.getName(), exc);
		}
		catch (NoSuchMethodException exc)
		{
			throw new TechnicalException("failed to get method = "
					+ zipMethodName + " on implementation class = "
					+ implClass.getName(), exc);
		}
	}
}
